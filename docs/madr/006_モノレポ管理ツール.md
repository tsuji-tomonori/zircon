# Architecture Decision Record: モノレポ管理ツールの選定

- **日付**: 2025-03-12
- **ステータス**: 提案中 (Proposed)

## 1. 背景 (Context)

本プロジェクト「zircon」は、以下を満たすタスク管理システムである。

- 無限に子タスクを生成可能なTODOアプリ
- 子タスク分解時にAIアシストを活用可能
- 複数の表示形式(表/カンバン/ツリー/ガントチャート)や豊富な検索・集計機能を提供
- ローカル環境ではDocker Compose、クラウドはAWSを利用する技術的制約がある

既存のADRでは、フロントエンド(React+Vite+TypeScript)、バックエンド(Node.js+TypeScript+Hono)、DB(PostgreSQL+Prisma)などの技術選定を行った。これらを**単一リポジトリ**で一元管理(Monorepo)する方針も示されているが、**どのようなモノレポ管理ツール(ワークスペース/ビルド管理ツール)を採用するか**は未定である。

プロジェクトのソースコード構造は以下を想定している。

- **フロントエンド**: React + TypeScript + Vite
- **バックエンド**: Node.js + TypeScript + Hono
- **DB/ORM**: PostgreSQL + Prisma
- **共通ライブラリ/型定義**: フロントエンド・バックエンドで共有するDTOやスキーマ(Zodなど)
- **インフラ構成**: Docker Composeによるローカル起動、AWS ECS/Fargateなどを用いた本番運用

このように複数のパッケージ/ディレクトリが単一のリポジトリに含まれ、かつ**型定義やスキーマを共有**しながら開発を進めるため、**モノレポ管理ツールの採用**を検討する。

## 2. 課題 (Problem)

1. **複数パッケージをまたぐ依存関係の管理**
   - フロントエンド、バックエンド、共通ライブラリを別々のディレクトリに配置する予定だが、それらの**依存バージョンを正しく同期**しながら開発・ビルド・テストを行う必要がある。

2. **ビルド・テストの最適化**
   - プロジェクトが拡大するに伴い、**すべてのパッケージを毎回フルビルド**すると時間がかかり、開発効率が落ちる。差分ビルドやキャッシュを活用し、ビルド時間を短縮したい。

3. **CI/CDパイプラインでの扱いやすさ**
   - プルリクエストやマージのたびに、変更されたパッケージのみをビルド・テストできる仕組みがあると良い。
   - ただし、学習コストや導入コストとのバランスも考慮が必要。

4. **チーム開発でのスケーラビリティ**
   - 将来的にモノレポ内のパッケージが増えたり、担当チームが増えたりした場合でも、混乱なく運用できるツールを選びたい。

## 3. 決定 (Decision)

### **pnpmワークスペース + (Turborepo または Nx) の導入を検討し、現時点ではシンプルにpnpmワークスペースを優先採用する。**

1. **パッケージ管理ツール**
   - **pnpm** を採用し、モノレポ内の依存関係を一元管理する。
   - Yarnやnpmのワークスペースも候補だが、pnpmはディスク使用量の削減や高いパフォーマンスで評価が高く、モノレポを扱いやすい。

2. **ビルド・テスト管理**
   - 当初は**pnpmスクリプト**(例: `pnpm run build --filter <package>`)や`"scripts"`セクションの活用で対応。
   - プロジェクト規模拡大時、**Turborepo**や**Nx**を導入し、差分ビルド・キャッシュ機能などを利用して開発効率を上げることを検討する。

3. **ディレクトリ構成**
   - リポジトリルートに`package.json`(ワークスペース設定)を置き、
     ```
     zircon/
     ├── package.json (pnpm workspace設定)
     ├── pnpm-lock.yaml
     ├── docker-compose.yml
     ├── zircon-frontend/
     ├── zircon-backend/
     ├── packages/
     │   └── shared/      (共通型・ユーティリティ)
     └── infra/           (AWSデプロイ関連)
     ```
   - フロントエンド、バックエンド、共通ライブラリなどをそれぞれワークスペースとして定義し、相互依存を`pnpm`で管理する。

4. **ビルド・テスト・デプロイフローの運用**
   - CI/CDパイプライン上でも`pnpm install`→`pnpm run build`→`pnpm run test`などを実行。
   - 将来的にパッケージ数が増えた場合、TurborepoやNxのキャッシュ機能でビルド効率を改善し、不要なパッケージの再ビルドをスキップする。

## 4. 選択肢 (Alternatives)

1. **Yarn Workspaces / npm Workspaces**
   - Yarnまたはnpmのワークスペース機能を使う場合でも、基本的な仕組みは同様。
   - ただしpnpmに比べると、インストールの仕組み(ハードリンク/シンボリックリンク)やキャッシュ挙動がやや異なる。大規模になるほどpnpmの利点が大きいと判断。

2. **Turborepo や Nx を最初から本格導入**
   - 大規模モノレポの差分ビルドやキャッシュ機能を強力にサポート。
   - ただし設定がやや複雑化し、学習コストも上がる。初期段階ではpnpmワークスペースだけでも十分なケースが多い。

3. **Lerna**
   - 旧来からのモノレポ管理ツール。
   - 近年は更新頻度やコミュニティ活発度の面でTurborepoやNxに比べやや劣る印象がある。

4. **各ディレクトリを完全独立リポジトリにする(ポリレポ)**
   - 依存管理やバージョン同期が複雑になり、型共有が多い本プロジェクトには向かない。
   - 小規模プロジェクトや緩やかに連携するサービス群ならアリだが、今回の要件では非推奨。

## 5. 根拠 (Rationale)

- **pnpmの優位性**:
  - パフォーマンス(高速インストール)、ストレージ効率(ハードリンク管理)、ワークスペース機能の使いやすさで近年支持が高い。
  - 既にReact+TypeScriptやNode.jsバックエンドでの活用実績が多く、ドキュメントも充実している。

- **初期実装のシンプルさを優先**:
  - まずはpnpmワークスペースだけでモノレポ構成を整え、ビルド・テスト・デプロイをスクリプト化。
  - チーム規模やパッケージ数が増加し、ビルド時間が問題化した時点で、TurborepoやNxを導入して差分ビルド・キャッシュを活用する段階的アプローチが適切と判断。

- **型定義・スキーマ共有**:
  - packages/sharedでZodスキーマやユーティリティを管理し、フロントエンド・バックエンド双方からimportする。
  - pnpmワークスペースにより、sharedパッケージを常に最新の状態で参照しやすい。

## 6. 結果 (Consequences)

- **ポジティブな影響**
  1. **依存管理の効率化**
     - フロント/バックエンド/共通パッケージでバージョンを揃えやすく、更新漏れを減らせる。
  2. **ビルド/テストの単純化**
     - 初期段階では`pnpm run build --filter zircon-backend`等で必要なパッケージだけビルド可能。
  3. **スケーラビリティ**
     - 今後の拡張時もモノレポ管理ツールとしてTurborepoなどを追加しやすい。

- **ネガティブな影響**
  1. **パッケージが増えるほどビルド時間が長くなる可能性**
     - 差分ビルド対応のためにはNxやTurborepoの導入を検討する必要がある。
  2. **pnpm固有の学習コスト**
     - npmやYarnに慣れている開発者には最初やや慣れが必要。
  3. **CI/CD設定が多少複雑化**
     - フィルタリングやキャッシュなどを活用する際、CIでのジョブ設定に配慮が要る。

## 7. 実装方針 (Implementation Notes)

1. **リポジトリ構成サンプル**

   ```
   zircon/
   ├── package.json            # "private": true, "workspaces": ["zircon-frontend", "zircon-backend", "packages/*"]
   ├── pnpm-lock.yaml
   ├── docker-compose.yml
   ├── zircon-frontend/
   │   ├── package.json
   │   ├── src/
   │   └── ...
   ├── zircon-backend/
   │   ├── package.json
   │   ├── src/
   │   └── prisma/
   ├── packages/
   │   └── shared/
   │       ├── package.json
   │       └── src/
   ├── infra/
   │   └── ...
   └── ...
   ```

   - ルート`package.json`でpnpmワークスペース設定を行い、フロントエンド/バックエンド/`packages/*`を対象とする。

2. **スクリプト例**

   - ルート`package.json`に以下のようなスクリプトを定義し、開発フローを統一する。

     ```jsonc
     {
       "scripts": {
         "install": "pnpm install",
         "build": "pnpm run build --filter ./zircon-frontend && pnpm run build --filter ./zircon-backend",
         "dev": "pnpm run dev --filter zircon-backend & pnpm run dev --filter zircon-frontend",
         "test": "pnpm run test --parallel"
       }
     }
     ```

   - 必要に応じて`pnpm recursive run <script>`や`pnpm run <script> --filter <package>`などを使い分ける。

3. **Docker Compose連携**

   - `docker-compose.yml`で`frontend`, `backend`, `db`などのサービスを定義し、ビルド時に`pnpm`コマンドを呼び出す。
   - ローカル開発で`docker-compose up`するだけでフロントとバックが起動するようにする。

4. **CI/CD設定**

   - GitHub Actionsなどで`pnpm install`→ビルド→テストのステップを定義。
   - 将来的にTurborepoやNxを導入する際は、差分ビルドのキャッシュをアクション内で設定し、全体のビルド時間を短縮できる。

5. **拡張ポイント**

   - 規模拡大に伴い、**TurborepoやNx**を導入することで、差分キャッシュやビルドグラフ可視化を利用しビルド効率を上げられる。
   - Lint/Format/TypeCheckなどの統合タスクも、ワークスペースでまとめて実行しやすい。

## 8. 今後の展望 (Future Considerations)

- **大規模化対応**
  - チームやパッケージが急激に増える場合、TurborepoやNxなど高機能ツールへの移行を早めに検討する。
- **バージョン管理**
  - 全パッケージを同じバージョンにするのか、パッケージ単位で独立したバージョン付けを行うのか(例: Lerna + Changesets)も、将来的なリリース戦略に応じて決定する。
- **ドキュメント生成**
  - OpenAPIやZodスキーマからの型自動生成など、ワークスペース内で完結する形に整備し、API仕様と実装が常に同期する仕組みを強化できる。
