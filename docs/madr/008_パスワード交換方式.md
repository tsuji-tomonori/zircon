# Architecture Decision Record: パスワード交換方式の選定

- **日付**: 2025-03-12
- **ステータス**: 提案中 (Proposed)

## 1. 背景 (Context)

本プロジェクト「zircon」は、以下の要件を満たすタスク管理システムである。

- 無限に子タスクを生成可能なTODOアプリ
- 子タスク分解時にAIアシストを利用可能
- メンバーやグループでタスクの作成／編集／閲覧／ステータス変更が可能
- ローカル環境ではDocker Composeを利用し、クラウドはAWS上にデプロイ

システムの認証面では「ユーザーはパスワードを用いてシステムにログインできる」ことが基本となる。
さらにセキュリティ要件として以下が挙げられている:

- 通信経路の暗号化 (TLS/SSL)
- DBへのパスワード平文保存の禁止 (安全なハッシュ化)
- ロールベースアクセス制御
- 2要素認証(2FA)などの拡張要件への対応可能性

したがって「パスワードをやり取りして認証する方式（パスワード交換方式）」について、どのような設計を採用するかを決定する必要がある。

## 2. 課題 (Problem)

1. **安全なパスワード交換**
   - ユーザーが入力するパスワードを、盗聴・改ざんのリスクなく安全にサーバへ送信し、認証できる仕組みが必要。
   - TLSで通信を保護するだけでなく、サーバ側で保管する際にハッシュやソルトを適切に処理し、漏洩時の被害を最小化する。

2. **将来の拡張 (2FA 等) に対応可能**
   - 初期はユーザー名 + パスワード認証のみの予定だが、今後2要素認証(TOTP, SMS, Emailリンクなど)を導入する可能性がある。
   - パスワード交換部分が脆弱だと拡張してもセキュリティ上の穴が残る。

3. **ユーザー体験 (UX) と開発コストのバランス**
   - パスワードレス認証やゼロ知識証明(SRP, PAKE)なども考えられるが、実装や運用の複雑度が大きくなりがち。
   - 一般的なフォーム認証 + 安全なハッシュ・ソルト運用の手法でも要件を満たせる可能性は高い。

4. **Docker Compose + AWS対応**
   - ローカル開発ではDocker Compose上での認証フローを検証でき、本番ではAWSの負荷分散(ALBなど)を通してTLS終端も行うケースが考えられる。
   - いずれにしてもHTTPS/TLS経由でのパスワード送信が前提となる。

## 3. 決定 (Decision)

**クラシックな「HTTPS + サーバ側でのハッシュ認証」方式**を採用し、以下を実施する:

1. **通信経路暗号化**
   - クライアント(ブラウザ等)とサーバ間の通信はすべてHTTPS/TLSで暗号化し、盗聴や改ざんを防ぐ。

2. **パスワードのサーバ保管方式**
   - パスワードを**平文で保存せず**、十分に強度のあるアルゴリズム(例: Argon2, scrypt, bcrypt等)でハッシュ化(ソルト付き)してDBに保存する。
   - DB漏洩時にもパスワードがすぐに逆算されるリスクを軽減する。

3. **認証フロー**
   - フロントエンド(Reactアプリ)上で、ユーザーはフォームに「ユーザーID or メールアドレス」と「パスワード」を入力。
   - HTTPS経由でサーバへ送信 → サーバ側がDB内のハッシュと比較し、認証を行う。
   - セッション方式 or JWT等のトークン方式でログイン状態を管理し、バックエンドAPIへのアクセスを保護する。

4. **将来的な2FA対応**
   - 認証が成功した後に、別途ワンタイムコード(TOTPやSMSコード)の入力を促す仕組みを拡張可能にする。
   - これによりパスワード単独よりもセキュリティを強化できる。

## 4. 選択肢 (Alternatives)

1. **SRP (Secure Remote Password) やPAKE (Password Authenticated Key Exchange)の導入**
   - ゼロ知識証明的なアプローチを用いて、クライアント-サーバ間で平文パスワードを直接やり取りせずに認証を行う高度な方式。
   - セキュリティは高くなるが、実装の複雑度が上がり、クライアントにも専用実装が必要。
   - 一般的なWebアプリの多くはHTTPSで保護されたフォーム送信 + サーバ側の安全なハッシュで十分とされるケースが多い。

2. **パスワードレス認証 (Magic Link, OAuth2/OIDC 等)**
   - ユーザー名/パスワードを用いず、メールやSNSアカウントで直接ログインする。
   - ユーザーの利便性が上がる反面、外部認証サービスの連携やフロー設計が複雑になる可能性がある。
   - 社内システムや既存ユーザー管理要件がある場合は切り替えに工数がかかる。

3. **二段階でのハッシュ(クライアント側 + サーバ側)**
   - クライアント側で一度ハッシュして送信、サーバ側でさらにハッシュする方式。
   - 中間者攻撃やリプレイ攻撃に対して追加の防御を意図する場合があるが、結局TLSを前提とするためメリットは限定的。
   - 実装の煩雑化やUXへの影響が大きい。

4. **デバイス認証との組み合わせ**
   - FIDO2 / WebAuthn など、パスワードを使わない認証もある。
   - ユーザー環境によっては導入が難しく、実装難易度も高いため、当面の要件を超える可能性が高い。

## 5. 根拠 (Rationale)

- **HTTPSでの保護**
  Webアプリで広く実践される標準的な方法。フォーム認証をTLSで暗号化すれば、平文パスワードが漏洩するリスクは大幅に低下する。
- **安全なハッシュ (Argon2, bcryptなど)**
  DB漏洩時のリスクを抑えるための不可欠な対策。NIST等の推奨でもあり、実装例が多く運用実績が豊富。
- **SRP/PAKEは実装コストが高い**
  一般的なWebサービスとしては、SRPやPAKEほどの高度なスキームを要するケースは稀。既存ライブラリも限定的。
  また、TLS通信自体がパスワードの盗聴を防いでいるため、コストと効果を天秤にかけると優先度は低い。
- **将来の2FA拡張**
  パスワードに加えTOTPなどを組み合わせる方が、総合的にセキュリティを高められる。サーバ側ロジックを増やすだけで導入できるので拡張しやすい。

## 6. 結果 (Consequences)

- **ポジティブな影響**
  1. 実装が比較的シンプルで、既存のライブラリやフレームワークを活用しやすい。
  2. セキュリティ水準としても、TLS + 高強度ハッシュ + 2FA拡張の組み合わせで十分高いレベルを維持できる。
  3. 新機能（2FAなど）を段階的に追加しやすい構成。

- **ネガティブな影響**
  1. SRPやPAKEのようなゼロ知識証明的手法ほどの理想的な「パスワード非依存」アプローチではない。
  2. パスワード再利用やフィッシング対策は別途考慮（ユーザー教育やUI上の注意喚起）が必要。
  3. クライアント側でのハッシュなどは行わないため、中間者攻撃への追加耐性は限定的（ただしTLSで保護しているため問題は小さい）。

## 7. 実装方針 (Implementation Notes)

1. **パスワードハッシュアルゴリズム**
   - Argon2、bcrypt、scryptなど、十分に実績があるアルゴリズムを利用する。
   - 設定ファイルや環境変数で「ストレッチ回数」「メモリコスト」などのパラメータを調整可能にする。

2. **ユーザー登録/パスワード変更フロー**
   - 登録時・変更時に入力されたパスワードをサーバ側でハッシュ化し、DBに保存。
   - パスワード平文はDBにもログにも残さない。ソルトは生成してハッシュに含めるか、別カラムで管理する。

3. **ログインフロー**
   - ユーザーがフォームにID/パスワードを入力 → HTTPSでサーバへ送信 → サーバがハッシュを検証。
   - 成功時にセッショントークンやJWTを発行。以降のAPIアクセスはそのトークンで認可チェックを行う。

4. **2FA拡張**
   - ログイン後に追加のワンタイムコード(TOTPやSMS)の入力を要求するフローをオプションで実装。
   - DBにユーザーごとの2FA設定やシークレットキー(TOTP用)を安全に保管し、必要なユーザーだけ機能を有効化できるようにする。

5. **AWSデプロイ時の注意**
   - ALBやCloudFrontなどでHTTPS終端する場合でも、バックエンドへの接続は常にTLSを維持するか、または同じVPC内のプライベート通信で安全を確保。
   - ハッシュ用のリソースコスト(Argon2など)を踏まえ、ECS/Fargateのスケーリング設定を行う。ユーザー数が多いとハッシュ計算がボトルネックになる場合がある。

6. **監査ログとアラート**
   - ログイン試行やパスワード変更など、認証まわりのイベントは監査ログに記録し、異常なログイン試行(ブルートフォース)のアラートを行う。

7. **運用フェーズのパスワードポリシー**
   - 文字数制限や複雑度(大文字/小文字/記号など)を適切に設定し、ユーザーが弱いパスワードを選ばないようUIでガイドする。
   - 定期的なパスワード変更を強制するかどうかは要件次第で検討。
