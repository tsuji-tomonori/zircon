# Architecture Decision Record: 認証・認可方式の選定

- **日付**: 2025-03-12
- **ステータス**: 提案中 (Proposed)

## 1. 背景 (Context)

本プロジェクト「zircon」は、以下の特徴を持つタスク管理システムである。

- 無限に子タスクを生成可能なTODOアプリ
- 子タスク分解時にAIアシストを利用可能
- メンバーおよびグループ単位でのタスクの作成／編集／閲覧／ステータス変更
- 通知・メンション機能や検索・集計機能が充実
- ローカル環境ではDocker Composeで動作、本番環境ではAWSを利用

システムには「ユーザー」「メンバー」「プロジェクト管理者」「システム管理者」といったロールが定義されており、プロジェクト単位での所属・権限管理が必要となる。またシステム管理者はプロジェクト横断的なユーザー招待・プロジェクト作成などが行える、より上位の権限を持つ。

本ADRでは、これら**多層のロール管理とプロジェクト単位の認可ルール**を実装するうえでの**認証・認可方式**を決定し、ローカル環境（Docker Compose）およびAWS上でスケーラブルに運用できる仕組みを検討する。

## 2. 課題 (Problem)

1. **複数ロールと細かな権限要件**
   - 要件にあるように「メンバー」「プロジェクト管理者」「システム管理者」などのロールが存在し、さらにプロジェクトごとのステータス変更可否や操作制限など、きめ細かい認可制御が必要。
   - グループ単位での担当者設定や通知など、タスク操作時に誰がどこまで権限を持つのかを統合的に管理しなければならない。

2. **ローカル環境／AWS本番環境両対応**
   - ローカルではDocker Composeにより一括起動し、開発・テストが容易である必要がある。
   - 本番環境ではAWS上でセキュアかつスケーラブルに運用可能なアーキテクチャが求められる。

3. **拡張性と将来的な認証方式追加**
   - 現在はID/パスワード認証を想定しているが、将来的に2要素認証(2FA)や外部IdP(SSO)連携などを導入する可能性がある。
   - スキームを固定しすぎると移行コストが高くなるため、認証認可モジュールには適度な拡張性を確保したい。

4. **アプリ内部のロール管理・権限制御をどこまで外部化するか**
   - Auth0やAWS Cognitoのようなマネージド認証基盤を使うか、KeycloakなどのOSS IdPをコンテナ運用するか、あるいはアプリ内で独自に実装するかが検討対象となる。

## 3. 決定 (Decision)

### **JWTベースの認証・認可をアプリケーション内で実装し、RBAC(Role-Based Access Control)を用いた柔軟な制御を行う。**
- **認証**
  - ID/パスワードによるログインを基本とし、ユーザーテーブルでアカウント情報を管理。
  - ログイン時にJWTトークンを発行し、クライアント(フロントエンド)側に保持させる。
  - パスワードはハッシュ化(Argon2などの安全なアルゴリズム)とソルトを行いDBに保存する。
  - 将来的な2FA(TOTP)追加や外部IdPとの連携を見据え、認証モジュールは拡張可能な構成にする。

- **認可**
  - JWTのペイロード内にユーザーID、ロール(システム管理者 / プロジェクト管理者 / メンバー)、および所属するプロジェクトID・グループIDなど、認可に必要な最低限の情報を含む。
  - バックエンド(Hono)のミドルウェアでJWTを検証し、アクセストークンが有効か・指定ロールまたはプロジェクト権限を満たしているかをチェックする。
  - プロジェクト・タスク単位の細かな権限(ステータス変更可否など)は、アプリケーション内部のRBAC/ABAC的なロジックで判定する。たとえば「ステータス変更できるロール」や「遷移可否のルール」をDB管理し、ミドルウェアあるいは各エンドポイントのハンドラで照合する。

- **インフラ構成**
  - ローカルではDocker Composeにより、PostgreSQL + Node.js(バックエンド) + React(フロントエンド)をまとめて起動。JWT発行・検証ロジックもバックエンド内に実装。
  - 本番ではAWS ECS(Fargate)上で同コンテナを動作させ、DBはRDS(PostgreSQL)を利用。
  - 将来的に認証基盤をAWS Cognitoへ移行する場合にも、JWT検証部分を切り替えやすいよう、バックエンド側はJWTの扱いを抽象化する設計とする。

## 4. 選択肢 (Alternatives)

1. **AWS Cognitoを直接採用**
   - AWSのマネージド認証基盤であり、ユーザープール管理や多要素認証、SNS連携などが容易。
   - ただしローカル開発での動作確認にやや手間がかかり(例えばLocalStack利用等)、プロジェクト内で要求される細かなロール・プロジェクト管理をCognitoグループだけで完結させるには実装の工夫が必要。

2. **KeycloakなどのOSS IdPをコンテナ運用**
   - KeycloakをDocker ComposeやKubernetes上で起動し、OpenID Connect / SAMLなどの標準プロトコルで認証認可を行う。
   - 大規模かつ複雑な要件に対応しやすいが、Keycloak自体の運用・バージョン管理が増え、学習コストも上がる。
   - 細かなプロジェクト単位のロール制御は、Keycloak側とアプリ側のどちらで管理するかを設計する必要がある。

3. **アプリケーション独自のセッション管理 (Cookie + セッションストア)**
   - JWTではなくサーバセッションを用いてCookieで認証情報を管理し、メモリやRedisにセッションを保存する方式。
   - フロントエンドSPAとの連携やスケールアウト時のセッション同期(StickyセッションやRedisクラスタ)が課題になりやすい。
   - マイクロサービス化やサーバレス化に移行しづらいため、将来的な拡張性がやや制限される。

4. **Auth0などのSaaS IdPを利用**
   - Cognitoに近いが、Auth0ならではのルールやテンプレートで柔軟に認証フローをカスタマイズできる。
   - 有償プランやユーザー数制限など、コスト面の検討が必要。
   - AWS環境との親和性はCognitoほど高くない場合もある。

## 5. 根拠 (Rationale)

- **JWTの利点**
  - SPA(React)との相性が良く、ステートレスかつスケーラブルにユーザー認証を実装できる。
  - ECSやLambdaなど、将来的に構成が変化しても比較的移植コストが小さい。

- **アプリ内実装のメリット**
  - 要件にある「プロジェクトごとのステータス遷移制御」「グループ別通知設定」などの細かい認可ロジックを**アプリケーションレイヤーで柔軟に組み込みやすい**。
  - Cognito/Keycloak等を導入しても結局アプリ内で独自のロール・権限テーブルを管理する必要が高く、シンプルなJWT実装からスタートするほうがスムーズと判断。

- **将来的な外部IdP連携への拡張性**
  - JWTの検証ロジック部分を抽象化しておけば、トークン発行元を自前DB→Cognito→他のIdPに変更する際も大幅な書き換えを避けられる。
  - 2要素認証を追加する場合も、ログインフローにOTP検証を追加するなど、Node.js側で柔軟に実装可能。

## 6. 結果 (Consequences)

- **ポジティブな影響**
  1. **ロールベースの細かな認可ロジック**をアプリケーションコードで直接コントロールでき、要件を満たしやすい。
  2. ローカル開発でDocker Compose起動のみで**一通りの認証・認可テスト**が行える。
  3. JWTステートレス認証により、**スケーラビリティ**や**サーバレス化**への移行ハードルが下がる。

- **ネガティブな影響**
  1. **セキュリティ実装の責任範囲**がアプリ開発側に大きくのしかかる。パスワード管理や2FA導入などをすべて自前で対応する必要がある。
  2. KeycloakやCognitoなどの**マネージド/OSS IdPが提供する機能(レポートやユーザー管理画面など)**を自前で用意しなければならない。
  3. 外部SSOが必須になった場合に、IdPとの連携部分を改修するコストが発生する（もっとも、事前に抽象化を設計していれば影響を局所化できる）。

## 7. 実装方針 (Implementation Notes)

1. **ユーザー登録・ログインフロー**
   - ユーザーテーブルに`email`・`hashed_password`・`role`・`…`などを保存。
   - ログイン成功時に`user_id`・`role`などを含むJWTを発行し、フロントエンドで保存(アクセストークン方式)。
   - トークンの有効期限(例:1時間)とリフレッシュトークンの仕組みを取り入れ、継続ログインを実装する。

2. **JWT検証ミドルウェア**
   - バックエンド(Hono)側で`Authorization: Bearer <token>`ヘッダを受け取り、JWTを検証。
   - 署名(HS256 or RS256)・有効期限などをチェックし、問題なければロール情報やユーザーIDをコンテキストに格納する。
   - 必要に応じてデコードしたユーザーIDを用いて、**DBから詳細情報**(プロジェクトごとの権限など)を取得し、エンドポイント単位でアクセス可否を判断する。

3. **プロジェクト単位の認可ロジック**
   - テーブル設計例:
     - `projects`テーブル：プロジェクト情報(管理者IDなど)
     - `project_members`テーブル：メンバー(ユーザーID, プロジェクトID, 役割など)
     - `statuses`テーブル：プロジェクトごとに定義されたステータスのリスト+遷移可能ロール
     - `tasks`テーブル：タスク情報(担当者ID/グループID, ステータスID, …)
   - APIハンドラで「ログインユーザーが対象タスクを操作可能か」を判定する際、JWTのユーザーIDとプロジェクト内のロールやステータス遷移ルールを組み合わせて検証する。

4. **将来的な2FAや外部認証連携**
   - ログインエンドポイントに2段階認証(例: TOTP)を追加する際は、JWT発行前に**OTPの有効性**をチェックする仕組みを挿入。
   - 外部IdP連携時には、IdPから受領したIDトークン(OIDC)を検証し、ユーザーテーブルと突合しつつJWTを再発行する形も可能。

5. **ローカル/本番運用**
   - **ローカル開発**: Docker ComposeでNode.js + DB(PostgreSQL)を起動し、すべてアプリケーション内で認証処理を行う。
   - **本番**: AWS ECS(Fargate)で同じコンテナを稼働させ、DBをRDS(PostgreSQL)で運用。JWTの秘密鍵/署名鍵はAWS Systems Manager Parameter StoreまたはAWS Secrets Managerで安全に保持する。

6. **監査・ログ出力**
   - 認証失敗ログ、ステータス変更時のユーザー情報などを監査ログとして記録し、AWS CloudWatchやElasticsearchなどに送信。
   - システム管理者が監査画面やログ解析ツールでアクセス状況や不正操作をモニタリングできるようにする。
