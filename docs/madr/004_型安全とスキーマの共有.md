# Architecture Decision Record: 型安全とスキーマ共有の方針

- **日付**: 2025-03-11
- **ステータス**: 提案中 (Proposed)

## 1. 背景 (Context)

本プロジェクト「zircon」は、無限に子タスクを生成できるタスク管理システムであり、AIアシストを活用した子タスク分解や、豊富な検索・集計・通知機能を提供する。フロントエンド／バックエンドともTypeScriptを採用し、Docker Compose上で動作するアプリケーションをAWSへデプロイすることが基本方針となっている。

本システムでは以下を強く求められている:

1. 型安全性の徹底
   - フロントエンドからバックエンド、DBスキーマまで、単一のソースあるいは整合の取れた形で型を管理し、データ不整合によるバグを低減させたい。
2. スキーマの一元管理・共有
   - ユースケースが増える中で、リクエスト/レスポンスやDBスキーマを別々に管理していると同期漏れや重複定義が増大する懸念がある。
   - できるだけ**単一のソース**から型定義を生成あるいは共有し、バックエンドで定義した型やバリデーションをフロントエンドでも使い回せるようにしたい。

既存のADRで決定している技術要素:

- **フロントエンド**: React + Vite + TypeScript
- **バックエンド**: Node.js + TypeScript + Hono
- **データベース & ORM**: PostgreSQL + Prisma
- **コンテナ化**: Docker Compose (ローカル開発) / AWS (本番運用)

上記技術スタックを前提に、**型定義の重複や齟齬を極力なくし、スキーマを一元管理する**ためのアプローチを検討する。

## 2. 課題 (Problem)

1. フロントエンドとバックエンド間のAPI契約をどのように型安全に保つか
   - たとえば、リクエスト/レスポンスのインターフェースを手書きで重複定義していると、更新漏れや差分が出た際にコンパイルエラーではなく実行時エラーとして発覚するリスクがある。
2. DBスキーマ（Prisma）とAPIスキーマの整合性をどのように担保するか
   - Prismaのモデル定義とAPIのDTO／エンティティ定義がズレると、どこかで変換ロジックが必要になり、メンテナンス負荷が高まる。
3. バリデーションの重複
   - フロントエンド側でフォームバリデーションを行い、バックエンド側でも同等のバリデーションを行う場合、スキーマ定義がずれるとユーザー体験やセキュリティに悪影響がある。
4. チーム開発での変更追従
   - スキーマが頻繁に変わる可能性がある場合、どこか単一の変更箇所を経由して自動生成や型共有ができる仕組みが望ましい。

## 3. 決定 (Decision)

1. バックエンド主導の型定義と自動生成の採用
   - バックエンドで Zod などのスキーマバリデーションライブラリを用いてAPIリクエスト/レスポンスのスキーマを定義し、それを TypeScript の型情報としてフロントエンドにエクスポート（または自動生成）する。
     - Hono + Zodのミドルウェアや、zod-to-ts, zod-to-openapi 等のツールによる型・ドキュメントの自動生成を活用する。
   - あるいは tRPC のように、バックエンドで定義した処理をTypeScript型のままフロントエンドが参照するアプローチも検討可能。
     - 本プロジェクトの要件ではRESTエンドポイントが中心となる可能性が高いため、ZodなどのスキーマとHonoの組み合わせを基本案とするが、要件次第ではtRPCを導入する。
2. PrismaスキーマとAPIスキーマの分離 + 必要最小限のマッピング
   - Prisma の `schema.prisma` はデータベース構造に特化したモデル定義とする。
   - バックエンドのドメイン層では、Prismaのモデル型を拡張・変換した「**DTO (Data Transfer Object)**」や「**エンティティ**」をZodスキーマとして定義し、APIの入出力チェックを行う。
   - ただし、**冗長な型変換をできるだけ減らす**ため、Prisma Client が生成する型を積極的に流用できる範囲は流用する。
3. 共通ライブラリ (npmパッケージ or monorepo) による型共有
   - フロントエンドとバックエンドが同一リポジトリの場合は、`packages/shared` 等のディレクトリを設け、Zodスキーマや型定義をエクスポートする仕組みを用意する。
   - 別リポジトリの場合でも、npm private registry や Git submodule などを利用し、**同一の型定義をインストールして参照**できる形にする。
4. 自動テストやCIでの型整合チェック
   - バックエンド側の Zod スキーマ (または tRPC ルータ) を変更した際、フロントエンド側のビルド／テストも同時に走らせるなど、**変更が衝突したら即検知**できるパイプラインを整備する。

## 4. 選択肢 (Alternatives)

1. OpenAPI (Swagger) ベース
   - バックエンドで OpenAPI スキーマ（YAML/JSON）を定義し、それをもとに `openapi-typescript` 等で型を自動生成してフロントエンドが利用する。
   - 標準的で可視化・ツールが豊富だが、OpenAPI定義の更新と実際の実装との同期を手動で行う場合、運用の煩雑さが生じやすい。Zod ⇔ OpenAPI の相互変換ツールが成熟してきているため組み合わせもあり得る。
2. Prismaスキーマを直接APIスキーマとして使う
   - Prismaのモデルをそのままフロントエンドでも定義として使い、リクエスト／レスポンス用の型をほとんど分けないアプローチ。
   - しかし、DB構造そのものが直接エンドポイントと1対1で対応するわけではなく、認証情報やバリデーション要件が絡むため、変更時の影響範囲が大きくなりがち。
3. 手書きの型定義を共有リポジトリで管理
   - ZodやOpenAPIの自動生成を導入せず、フロントエンドとバックエンドで共通の `.d.ts` or `.ts` ファイルを手書きでメンテナンスする。
   - シンプルだが、更新漏れが発生した際に自動検知しにくい。

## 5. 根拠 (Rationale)

- Zodを用いたスキーマファーストの実装

  は、APIリクエスト／レスポンスの型とバリデーションを一元化しやすい。

  - バックエンド内部でZodスキーマに通すことで入力データを厳密にチェック可能、同時にその型情報をフロントエンドに公開できる。

- Prismaモデルを直接フロントエンドに晒さない

  ことで、DBスキーマの変更に伴うフロントエンドへの影響を最小化できる。

  - たとえばパスワードや内部用のフラグが含まれるテーブルをそのまま外部に出したくない場合がある。DTOレイヤーを挟むことでセキュリティ・最適化のコントロールが可能。

- monorepo構成

   (またはnpmパッケージ化) でバックエンドとフロントエンドが同一の型定義を参照するようにすれば、

  型の不一致が起こった際にコンパイル時に検出

  しやすい。

  - CI上で一括ビルド・テストすることで、型の衝突が発生した場合に早期に把握できる。

## 6. 結果 (Consequences)

- ポジティブな影響
  - フロントエンドとバックエンドの型が自動・半自動で同期するため、実装の一貫性が高まり開発効率が向上する。
  - バックエンドでのスキーマ変更が即座にフロントエンド側で型エラーとして検出され、**実行時エラーより先にコンパイル時エラーで気づける**。
  - セキュリティやバリデーション要件を明示的にZodスキーマに書けるため、**ユースケースごとに厳密なバリデーション**を実装できる。
- ネガティブな影響
  - Zod等のスキーマ構成やDTOレイヤーなど、設定ファイルやコード量が一定増える。
  - PrismaスキーマとZodスキーマを完全に自動同期する仕組みではないため(一部ツールはあるが制約も多い)、**DBスキーマ変更→Prismaモデル変更→Zodスキーマ変更** というフローは意識的に運用が必要。
  - monorepoでない場合、npm private registry などを整備する手間がかかる。CIのセットアップにも注意が必要。

## 7. 実装方針 (Implementation Notes)

1. **monorepo構成（推奨例）**

   ```
   zircon/
   ├── packages/
   │   ├── shared-types/
   │   │   ├── src/
   │   │   │   ├── schemas/
   │   │   │   │   ├── task.schema.ts        (Zodスキーマ)
   │   │   │   │   ├── project.schema.ts
   │   │   │   │   └── ...
   │   │   │   └── index.ts                  (エクスポートポイント)
   │   │   ├── package.json
   │   │   └── ...
   │   └── ...
   ├── zircon-backend/
   │   ├── src/
   │   │   ├── routes/
   │   │   └── db/
   │   ├── prisma/
   │   │   └── schema.prisma
   │   └── ...
   ├── zircon-frontend/
   │   └── ...
   └── package.json
   ```

   - `shared-types` パッケージでZodスキーマや共通型を定義し、バックエンド・フロントエンドでimportする。
   - バックエンド内で `import { taskSchema } from 'shared-types'` として入力バリデーションを実施。
   - フロントエンドも同じ `taskSchema` やそこから派生した型を利用してフォームバリデーション・型補完を行う。

2. **Zod と Hono の組み合わせ**

   - 例: [@hono/validator](https://github.com/honojs/hono/tree/main/packages/validator) などを利用し、`ctx.req` の body/query/params をZodスキーマで検証し、型安全に取得する。
   - バリデーションエラー時に400を返し、フロントエンドではそれをハンドリングする。

3. **DBアクセス (Prisma) → DTO 変換**

   - `await prisma.task.findUnique(...)` で取得したデータをZodの`taskSchema`で `.parse()` or `.safeParse()` するか、あるいはDTO層で不要フィールドを除外して返却する。
   - エンティティとAPI向けDTO（Zodスキーマ）が1:1でない場合はマッピング関数を作成する（例: `toTaskDTO(prismaTask: PrismaTask): TaskDTO`）。

4. **CIでの一元テスト**

   - monorepoなら `pnpm` や `turbo`, `nx` などのツールを用いて、バックエンドを更新した際にフロントエンドの型チェックも並行して実施し、衝突を早期に検出する。

5. **拡張や代替**

   - もし**リアルタイム通信**(WebSocketなど)が増え、API定義や型共有が増大する場合は**tRPC**に移行し、フロントエンドがバックエンドの型を直接参照する形も検討する。
   - **OpenAPI**による外部向けAPIドキュメントを自動生成したい場合は `zod-to-openapi` を併用すればZodスキーマ→OpenAPI仕様を生成可能。
